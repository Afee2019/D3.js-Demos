<!DOCTYPE html>
<html>
  <head>
    <title>ThemeRiver</title>
    <link rel="stylesheet" href="/static/css/themeriver.css"> 
    <script src="/static/js/d3.min.js"></script>
  </head>
  <body style="text-align: center">
    <svg width="1650" height="920" id="mainsvg" class="svgs" style="background-color: #333333;"></svg>
    <script>
        // get main SVG and its attributes & setting hyper-parameters; 
        const svg = d3.select('#mainsvg');
        const width = +svg.attr('width');
        const height = +svg.attr('height');
        const margin = {top: 100, right: 120, bottom: 100, left: 120};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        const xValue = (datum) => {return dates.indexOf(datum['日期'])};
        const yValue = (datum) => {return datum['新增确诊']};
        //const xValue = d => d['确诊人数'];
        //const xValue = d => d['感染率'];
        //const yValue = d => {return Math.log(d['diffuse_smooth'] + 1)};
        //const yValue = d => {return d['diffuse_smooth']};
        //const yValue = d => {return Math.log(d['newinfec']+1)};
        //const rValue = d => {return Math.sqrt(d['确诊人数']) + 6};
        let low_max = 4000; 
        let up_max = 1000;
        let xScale, yScale, nyScale;
        let maxX, maxY;
        let dates; 
        let aduration = 1000;
        let metapop;

        const renderinit = function(data, seq){
            
            // Linear Scale: Data Space -> Screen Space; 
            xScale = d3.scaleLinear()
            .domain(d3.extent(data, xValue))
            .range([0, innerWidth])
            .nice();

            dataXScale = d3.scaleBand()
            .domain(dates)
            .range([0, innerWidth]);

            // Introducing y-Scale; 
            console.log(low_max, up_max)
            yScale = d3.scaleLinear()
            .domain([-low_max, up_max]) // "extent" is equivalent to [d3.min(data, xValue), d3.max(data, xValue)]; 
            .range([innerHeight, 0])
            .nice();

            nyScale = d3.scaleLinear()
            .domain([low_max, -up_max])
            .range([innerHeight, 0])
            .nice();

            // generate maxX and maxY; 
            maxX = xScale(d3.max(data, xValue));
            maxY = yScale(d3.max(data, yValue));

            // The reason of using group is that nothing is rendered outside svg, so margin of svg is always blank while margin of group is rendered inside svg; 
            const g = svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`)
            .attr('id', 'maingroup');

            svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`)
            .attr('id', 'hubeigroup');

            // Adding axes; 
            const yAxis = d3.axisLeft(yScale)
            .tickSize(-innerWidth)
            .tickFormat(d3.format('.2s'))
            .tickPadding(10); // .tickPadding is used to prevend intersection of ticks; 
            const xAxis = d3.axisBottom(dataXScale)
            //.tickFormat(d3.format('.2s'))
            .tickSize(-innerHeight)
            .tickPadding(10);

            let yAxisGroup = g.append('g').call(yAxis).attr('id', 'yaxis');;
            yAxisGroup.append('text')
            .attr('transform', `rotate(-90)`)
            .attr('x', -innerHeight / 2)
            .attr('y', -80)
            .attr('fill', 'white')
            .text('纵轴')
            .attr('text-anchor', 'middle') // Make label at the middle of axis. 
            yAxisGroup.selectAll('.domain').remove(); // we can select multiple tags using comma to seperate them and we can use space to signify nesting; 
            
            let xAxisGroup = g.append('g').call(xAxis)
            .attr('transform', `translate(${0}, ${innerHeight})`);
            xAxisGroup.append('text')
            .attr('y', 60)
            .attr('x', innerWidth / 2)
            .attr('fill', 'white')
            .text(' ')
            .attr('id', 'xaxis');
            xAxisGroup.selectAll('.domain').remove();
        };
        
        const render = function(data, keys, area){
            let g;
            if(keys.includes('湖北')){
                g = d3.select('#maingroup');
            }else{
                g = d3.select('#hubeigroup');
            }

            let layers = d3.stack()
            .keys(keys)
            .offset(d3.stackOffsetNone) 
            //.order(d3.stackOrderDescending)
            .order(d3.stackOrderNone)
            (data);
            console.log(layers);  

            const path = g.selectAll("path")
            .data(layers)
            .enter().append("path")
            .attr("d", area)
            // fill attrbute requires designers to assign colors for each province; 
            .attr("fill", () => d3.interpolateCool(Math.random()));
        };

        const seqgen = function(data){
            // re-arrange the data sequentially; 
            let prestack = []; 
            dates.forEach(datum => {
                prestack.push({'日期': datum});
            });
            data.forEach(datum => {
                //sequential[alldates.indexOf(datum['日期'])].push(datum);
                prestack[dates.indexOf(datum['日期'])][datum['省份']] = yValue(datum);
            });
            return prestack
        }

        d3.csv('./static/data/province.csv').then(function(data){
            data.forEach(datum => {
                // pre-process the data; 
                datum['确诊人数'] = +(datum['确诊人数']);
                datum['治愈人数'] = +(datum['治愈人数']);
                datum['死亡人数'] = +(datum['死亡人数']);
                datum['新增确诊'] = +(datum['新增确诊']);
            });

            // delete '总计'; 
            data = data.filter(datum => {return datum['省份'] !== '总计'});

            // remove duplicated items; 
            alldates = Array.from(new Set(data.map( datum => datum['日期'])));

            // make sure dates are listed according to real time order; 
            alldates = alldates.sort(function(a,b){
                // turn your strings into dates, and then subtract them
                // to get a value that is either negative, positive, or zero.
                return new Date(b.date) - new Date(a.date);
            });
            dates = alldates;

            // generate sequential data; 
            let sequential = []; 
            alldates.forEach(datum => {
                sequential.push([]);
            });
            data.forEach(datum => {
                sequential[alldates.indexOf(datum['日期'])].push(datum);
            });
            console.log(sequential);

            // split data from Hu-Bei and not from Hu-Bei; 
            data_hubei = data.filter(datum => {return datum['省份'] === '湖北'});
            data = data.filter(datum => {return datum['省份'] !== '湖北'});

            // stack data; 
            let prestack = seqgen(data);
            let prestack_hubei = seqgen(data_hubei);
            let keys = Array.from(new Set(data.map( datum => datum['省份'])));
            let keys_hubei = Array.from(new Set(data_hubei.map( datum => datum['省份'])));

            // generate low_max and up_max for Y-scale; 
            up_max = d3.max(sequential, seq => {
                console.log(seq);
                result = 0;
                seq.forEach(s => {
                    if(s['省份'] !== '湖北'){
                        result += yValue(s);
                    }
                })
                return result;
            })
            low_max = d3.max(sequential, seq => {
                result = 0;
                seq.forEach(s => {
                    if(s['省份'] === '湖北'){
                        result += yValue(s);
                    }
                })
                return result;
            })
            console.log(low_max, up_max)

            // initialize the chart; 
            renderinit(data);

            const area = d3.area()
            .x(d => xScale(xValue(d.data)))
            .y0(d => yScale(d[0]))
            .y1(d => yScale(d[1]));

            const area_hubei = d3.area()
            .x((d) => xScale(xValue(d.data)))
            .y0(d => nyScale(d[0]))
            .y1(d => nyScale(d[1]));

            // set the animation interval; 
            render(prestack, keys, area);
            render(prestack_hubei, keys_hubei, area_hubei);
        });
    </script>
  </body>
</html>