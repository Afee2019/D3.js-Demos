<!DOCTYPE html>
<html>
  <head>
    <title>StackBarChart</title>
    <script src="static/js/d3.min.js"></script>
    <script src="static/js/axes.js"></script>
    <script src="static/js/library/moment.min.js"></script>
  </head>
  <body>
    <svg width="1600" height="800" id="mainsvg" class="svgs"></svg>
    <script>
      const svg = d3.select('#mainsvg');
      const width = +svg.attr('width');
      const height = +svg.attr('height');
      const margin = {top: 60, right: 100, bottom: 60, left: 100};
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;
      const xValue = d => moment(d.month.toISOString()).format('YYYY-M-D');
      const yValue = d => d.occur;
      let xScale, yScale, color; 
      let allsemantics;

      const renderInit = function(data){
        const g = svg.append('g').attr('id', 'maingroup')
        .attr('transform', `translate(${margin.left}, ${margin.top})`); 

        yScale = d3.scaleLinear()
        .domain([0, d3.max(data, d => d3.max(d, subd => subd[1]))])
        .range([innerHeight, 0])
        .nice();

        xScale = d3.scaleLinear()
        .domain([0, d3.max(data, d => d3.max(d, subd => subd.data.x1))])
        .range([0, innerWidth])
        .nice();

        color = d3.scaleBand()
        .domain(allsemantics)
        .range([0, 1]);

        naiveAxes(g, innerWidth, innerHeight, xScale, yScale);
        d3.selectAll('.tick text').attr('font-size', '1.8em');
      }

      const render = function(data){
        // use d3.interpolateRainbow(t) to set colors; 
        // start to do data-join; 
        d3.select('#maingroup').selectAll('.datagroup').data(data).join('g')
        .attr('class', 'datagroup')
        .attr('fill', d => d3.interpolateRainbow(color(d.key)))
        .selectAll('.datarect').data(d => d).join('rect')
        .attr('class', 'datarect')
        .attr('y', d => yScale(d[1]))
        .attr('x', d => xScale(d.data.x0))
        .attr('height', d => yScale(d[0]) - yScale(d[1]))
        .attr('width', d => xScale(d.data.x1 - d.data.x0)); 
      }

      d3.csv('./static/data/suncg_occur.csv').then( data=> {
        data.forEach( d => {
          d.occur = +(d.occur);
        });

        allsemantics = data.map( d => d.semantic );
        allsemantics = Array.from( new Set(allsemantics) );
        console.log(allsemantics)

        let alloccur = {}
        allsemantics.forEach( s => {
          alloccur[s] = 0;
        } );
        data.forEach( d => {
          alloccur[d.semantic] += d.occur; 
        } );

        let histogram = d3.histogram()
        .value(yValue)
        .domain([0, d3.max(data, yValue)])

        // re-arrange the "historgramed" data

        var stack = d3.stack()
        .keys(allsemantics)
        .order(d3.stackOrderNone)
        .offset(d3.stackOffsetNone)

        let bins = histogram(data)
        
        // start to prepare the stack-histogram data; 
        hist = []
        bins.forEach( b => {
          let h = {}
          allsemantics.forEach( s => {
            h[s] = 0;
          } )
          hist.push(h)
        } ); 
        bins.forEach( (b, i) => {
          b.forEach( item => {
            hist[i][item.semantic] += 1;
          } );
          hist[i].x0 = b.x0;
          hist[i].x1 = b.x1;
        } );
        stackedHist = stack(hist);
        console.log('bins: ', bins)
        console.log('hist: ', hist)
        console.log('stackedHist: ', stackedHist);

        renderInit(stackedHist);
        render(stackedHist);
      } )

    </script>
  </body>
</html>