<!DOCTYPE html>
<html>
  <head>
    <title>Scatter</title>
    <link rel="stylesheet" href="/static/css/nCov.css"> 
    <script src="/static/js/d3.min.js"></script>
  </head>
  <body>
    <svg width="1600" height="860" id="mainsvg" class="svgs"></svg>
    <script>
        // get main SVG and its attributes & setting hyper-parameters; 
        const svg = d3.select('#mainsvg');
        const width = +svg.attr('width');
        const height = +svg.attr('height');
        const margin = {top: 60, right: 120, bottom: 80, left: 120};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        //const xValue = (datum) => {return dates.indexOf(datum['日期'])};
        //const yValue = (datum) => {return datum['确诊人数']};
        //const xValue = d => d['确诊人数'];
        const xValue = d => d['感染率'];
        const yValue = d => d['diffuse_smooth'];
        const rValue = d => {return Math.sqrt(d['确诊人数']) + 6};
        let xScale, yScale;
        let maxX, maxY;
        let dates; 
        let aduration = 1000;
        let metapop;

        const renderinit = function(data){
            // Linear Scale: Data Space -> Screen Space; 
            xScale = d3.scaleLinear()
            .domain(d3.extent(data, xValue))
            .range([0, innerWidth])
            .nice();

            // Introducing y-Scale; 
            yScale = d3.scaleLinear() // Instead of scaleBand, we use scale point; 
            .domain(d3.extent(data, yValue).reverse()) // "extent" is equivalent to [d3.min(data, xValue), d3.max(data, xValue)]; 
            .range([0, innerHeight])
            .nice();

            // generate maxX and maxY; 
            maxX = xScale(d3.max(data, xValue));
            maxY = yScale(d3.max(data, yValue));

            // The reason of using group is that nothing is rendered outside svg, so margin of svg is always blank while margin of group is rendered inside svg; 
            const g = svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`)
            .attr('id', 'maingroup');

            // Adding axes; 
            const yAxis = d3.axisLeft(yScale)
            .tickSize(-innerWidth)
            .tickPadding(10); // .tickPadding is used to prevend intersection of ticks; 
            const xAxis = d3.axisBottom(xScale)
            //.tickFormat(d3.format('.2s'))
            .tickSize(-innerHeight)
            .tickPadding(10);

            let yAxisGroup = g.append('g').call(yAxis);
            yAxisGroup.append('text')
            .attr('transform', `rotate(-90)`)
            .attr('x', -innerHeight / 2)
            .attr('y', -80)
            .attr('fill', 'black')
            .text('扩散指数（当日确诊/上日确诊 - 1）')
            .attr('text-anchor', 'middle') // Make label at the middle of axis. 
            .attr('id', 'yaxis');
            yAxisGroup.selectAll('.domain').remove(); // we can select multiple tags using comma to seperate them and we can use space to signify nesting; 
            
            let xAxisGroup = g.append('g').call(xAxis)
            .attr('transform', `translate(${0}, ${innerHeight})`);
            xAxisGroup.append('text')
            .attr('y', 60)
            .attr('x', innerWidth / 2)
            .attr('fill', 'black')
            .text('感染率（每万人累计确诊数）')
            .attr('id', 'xaxis');
            xAxisGroup.selectAll('.domain').remove();
        };

        const renderupdate = function(seq){
            const g = d3.select('#maingroup');
            circleupdates = g.selectAll('circle').data(seq, d => d['地区']);
            circleenter = circleupdates.enter().append('circle')
            .attr('cy', (datum) => { return yScale(yValue(datum)) })
            .attr('cx', (datum) => { return xScale(xValue(datum)) }) // use xSacle to re-scale data space (domain) and return the rescaled population; 
            .attr('r', datum => rValue(datum))
            .attr('fill', 'green') // #3fd4c5
            .attr('opacity', 0.4);
            circleupdates.merge(circleenter).transition().ease(d3.easeLinear).duration(aduration)
            .attr('cy', (datum) => { return yScale(yValue(datum)) })
            .attr('cx', (datum) => { return xScale(xValue(datum)) }) // use xSacle to re-scale data space (domain) and return the rescaled population; 
            .attr('r', datum => rValue(datum));
            console.log(seq);
        };

        d3.csv('./static/data/hubeipop.csv').then(data => {
            data.forEach(datum => {
                datum['人口（万人）'] = +(datum['人口（万人）']);
            })
            metapop = data;
        });

        d3.csv('./static/data/hubei.csv').then(function(data){
            
            data = data.filter(datum => {return datum['地区'] !== '总计'});
            data.forEach(datum => {
                // pre-process the data; 
                datum['确诊人数'] = +(datum['确诊人数']);
                datum['治愈人数'] = +(datum['治愈人数']);
                datum['死亡人数'] = +(datum['死亡人数']);
                if(isNaN(datum['扩散曲线'])){
                    datum['扩散曲线'] = 0.0;
                }else{
                    datum['扩散曲线'] = +(datum['扩散曲线']);
                }
                datum['感染率'] = datum['确诊人数'] / (metapop.find(x => x['地区'] === datum['地区'])['人口（万人）']);
            });

            // remove duplicated items; 
            alldates = Array.from(new Set(data.map( datum => datum['日期'])));

            // make sure dates are listed according to real time order; 
            alldates = alldates.sort();
            dates = alldates;

            // re-arrange the data sequentially; 
            sequential = []; 
            alldates.forEach(datum => {
                sequential.push([]);
            });
            data.forEach(datum => {
                sequential[alldates.indexOf(datum['日期'])].push(datum);
            });
            
            // smoothing '扩散曲线'; 
            let t = 0;
            for(; t < sequential.length; t++){
                sequential[t].forEach(datum => {
                    if(t == 0){
                        datum['diffuse_smooth'] = datum['扩散曲线'];
                    }else if(t == 1){
                        datum['diffuse_smooth'] = (
                            datum['扩散曲线'] + 
                            sequential[t-1].find(x => x['地区'] === datum['地区'])['扩散曲线']
                        ) / 2.0;
                    }else{
                        datum['diffuse_smooth'] = (
                            datum['扩散曲线'] + 
                            sequential[t-1].find(x => x['地区'] === datum['地区'])['扩散曲线'] + 
                            sequential[t-2].find(x => x['地区'] === datum['地区'])['扩散曲线']
                        ) / 3.0;
                    }
                })
            }

            // initialize the chart; 
            renderinit(data);

            // set the animation interval; 
            let c = 0; 
            intervalId = setInterval(function(){
                renderupdate(sequential[c]);
                console.log(c);
                if(c > alldates.length){
                    console.log('time to close this animation');
                    clearInterval(intervalId); 
                }
                c++;
            }, aduration); 
        });
    </script>
  </body>
</html>